EOL = _{(" " | "\t" | "\r")* ~ ("\n" | EOI)}
WHITESPACE = _{ " " | "\t" }

primitive_task         =  { EOL? ~ "primitive_task" ~ STRING ~ "{" ~ EOL? ~ 
                            (comment | operator_statement | effect_statement | expected_effect_statement | precondition_statement)* 
                        ~ "}" ~ EOL }
compound_task          =  { EOL? ~ "compound_task" ~ STRING ~ "{" ~ EOL? ~ (comment |  method)* ~ "}" ~ EOL }
method                 =  { "method" ~ "{" ~ EOL? ~ (comment | precondition_statement | subtask_statement)* ~ "}" ~ EOL }
subtask_statement      =  { "subtask:" ~ identifier ~ EOL }
precondition_statement =  { "precondition:" ~ condition ~ EOL }
effect_statement       =  { "effect:" ~ effect ~ EOL }
expected_effect_statement = { "expected_effect:" ~ effect ~ EOL }

operator_statement =  { "operator:" ~ operator_def ~ EOL  }
operator_def       =  { identifier ~ ("(" ~ operator_param* ~ ")")? }
operator_param     = @{ identifier }


condition  = { identifier ~ operator ~ (value | enum_value) }
operator   = { ">=" | ">" | "<=" | "<" | "==" }
effect     = { set_effect | inc_effect | dec_effect }
// greedy parser, so check for enum_value first otherwise identifier is found before the ::
set_effect = { identifier ~ "=" ~ (value | enum_value | identifier) }
inc_effect = { identifier ~ "+=" ~ value }
dec_effect = { identifier ~ "-=" ~ value }

identifier = @{ (ASCII_ALPHANUMERIC | "_")+ }
enum_value = @{ identifier ~ "::" ~ identifier }
value      = @{ ("true" | "false") | "-"? ~ ASCII_DIGIT+ }
STRING     = @{ "\"" ~ ((!"\"" ~ ANY))* ~ "\"" }

comment = _{ ("#" | "//") ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }

htn = { SOI ~ WHITESPACE* ~ (comment | primitive_task | compound_task)+ ~ WHITESPACE* ~ EOI }
