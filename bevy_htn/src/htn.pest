WHITESPACE = _{ " " | "\t" | "\n" }

primitive_task         =  { "primitive_task" ~ STRING ~ "{" ~ (comment | operator_statement | effect_statement | expected_effect_statement | precondition_statement)* ~ "}" }
compound_task          =  { "compound_task" ~ STRING ~ "{" ~ (comment |  method)* ~ "}" }
method                 =  { "method" ~ "{" ~ (comment | precondition_statement | subtask_statement)* ~ "}" }
subtask_statement      =  { "subtask:" ~ identifier ~ ";" }
precondition_statement =  { "precondition:" ~ condition ~ ";" }
effect_statement       =  { "effect:" ~ effect ~ ";" }
expected_effect_statement = { "expected_effect:" ~ effect ~ ";" }

operator_statement =  { "operator:" ~ (spawn_operator | trigger_operator) }
spawn_operator     =  { "spawn:" ~ operator_def ~ ";" }
trigger_operator   =  { "trigger:" ~ operator_def ~ ";" }
operator_def       =  { identifier ~ ("(" ~ operator_param* ~ ")")? }
operator_param     = @{ identifier }


condition  = { identifier ~ operator ~ (value | enum_value) }
operator   = { ">" | "==" }
effect     = { set_effect | inc_effect }
// greedy parser, so check for enum_value first otherwise identifier is found before the ::
set_effect = { "set" ~ identifier ~ "=" ~ (value | enum_value | identifier) }
inc_effect = { "inc" ~ identifier ~ "by" ~ value }

identifier = @{ (ASCII_ALPHANUMERIC | "_")+ }
enum_value = @{ identifier ~ "::" ~ identifier }
value      = @{ ("true" | "false") | "-"? ~ ASCII_DIGIT+ }
STRING     = @{ "\"" ~ ((!"\"" ~ ANY))* ~ "\"" }

comment = _{ ("#" | "//") ~ (!"\n" ~ ANY)* ~ ("\n" | EOI) }

htn = { SOI ~ WHITESPACE* ~ (comment | primitive_task | compound_task)+ ~ WHITESPACE* ~ EOI }
